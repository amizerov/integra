'use server'

import { prisma } from '@/lib/db'
import { auth } from '@/lib/auth'
import { revalidatePath } from 'next/cache'
import { z } from 'zod'

const connectionSchema = z.object({
  sourceSystemId: z.number(),
  targetSystemId: z.number(),
  sourceVersionId: z.number().optional(),
  targetVersionId: z.number().optional(),
  connectionName: z.string().optional(),
  description: z.string().optional(),
  dataFormat: z.enum(['JSON', 'XML', 'CSV', 'REST_API', 'SOAP', 'GRAPHQL', 'DATABASE_LINK', 'FILE_EXCHANGE', 'MESSAGE_QUEUE', 'CUSTOM']),
  exchangeFormat: z.string().optional(),
  masterVersionId: z.number().optional(),
  isActive: z.boolean().default(true),
  isBidirectional: z.boolean().default(false),
})

export async function getConnections() {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  const connections = await prisma.connection.findMany({
    include: {
      sourceSystem: {
        select: {
          id: true,
          systemCode: true,
          systemName: true,
        },
      },
      targetSystem: {
        select: {
          id: true,
          systemCode: true,
          systemName: true,
        },
      },
      sourceVersion: {
        select: {
          id: true,
          versionCode: true,
          platformType: true,
        },
      },
      targetVersion: {
        select: {
          id: true,
          versionCode: true,
          platformType: true,
        },
      },
    },
    orderBy: { createdAt: 'desc' },
  })

  return connections
}

export async function getConnectionById(id: number) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  const connection = await prisma.connection.findUnique({
    where: { id },
    include: {
      sourceSystem: true,
      targetSystem: true,
      sourceVersion: true,
      targetVersion: true,
    },
  })

  return connection
}

export async function createConnection(formData: FormData) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  const rawData = {
    sourceSystemId: parseInt(formData.get('sourceSystemId') as string),
    targetSystemId: parseInt(formData.get('targetSystemId') as string),
    sourceVersionId: formData.get('sourceVersionId') ? parseInt(formData.get('sourceVersionId') as string) : undefined,
    targetVersionId: formData.get('targetVersionId') ? parseInt(formData.get('targetVersionId') as string) : undefined,
    connectionName: formData.get('connectionName') as string || undefined,
    description: formData.get('description') as string || undefined,
    dataFormat: formData.get('dataFormat') as any,
    exchangeFormat: formData.get('exchangeFormat') as string || undefined,
    masterVersionId: formData.get('masterVersionId') ? parseInt(formData.get('masterVersionId') as string) : undefined,
    isActive: formData.get('isActive') === 'true',
    isBidirectional: formData.get('isBidirectional') === 'true',
  }

  const validated = connectionSchema.parse(rawData)

  const connection = await prisma.connection.create({
    data: validated,
  })

  revalidatePath('/connections')
  revalidatePath('/dashboard')

  return { success: true, connection }
}

export async function updateConnection(id: number, formData: FormData) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  const rawData = {
    sourceSystemId: parseInt(formData.get('sourceSystemId') as string),
    targetSystemId: parseInt(formData.get('targetSystemId') as string),
    sourceVersionId: formData.get('sourceVersionId') ? parseInt(formData.get('sourceVersionId') as string) : undefined,
    targetVersionId: formData.get('targetVersionId') ? parseInt(formData.get('targetVersionId') as string) : undefined,
    connectionName: formData.get('connectionName') as string || undefined,
    description: formData.get('description') as string || undefined,
    dataFormat: formData.get('dataFormat') as any,
    exchangeFormat: formData.get('exchangeFormat') as string || undefined,
    masterVersionId: formData.get('masterVersionId') ? parseInt(formData.get('masterVersionId') as string) : undefined,
    isActive: formData.get('isActive') === 'true',
    isBidirectional: formData.get('isBidirectional') === 'true',
  }

  const validated = connectionSchema.parse(rawData)

  const connection = await prisma.connection.update({
    where: { id },
    data: validated,
  })

  revalidatePath('/connections')
  revalidatePath(`/connections/${id}`)
  revalidatePath('/dashboard')

  return { success: true, connection }
}

export async function deleteConnection(id: number) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  await prisma.connection.delete({
    where: { id },
  })

  revalidatePath('/connections')
  revalidatePath('/dashboard')

  return { success: true }
}

// Получить граф связей для визуализации
export async function getConnectionsGraph() {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Не авторизован')
  }

  const [systems, connections] = await Promise.all([
    prisma.system.findMany({
      where: { isActive: true },
      include: {
        _count: {
          select: { versions: true },
        },
      },
    }),
    prisma.connection.findMany({
      where: { isActive: true },
      include: {
        sourceSystem: {
          select: {
            systemCode: true,
            systemName: true,
          },
        },
        targetSystem: {
          select: {
            systemCode: true,
            systemName: true,
          },
        },
      },
    }),
  ])

  // Формируем узлы графа
  const nodes = systems.map((system: any) => ({
    id: `system-${system.id}`,
    label: system.systemCode,
    systemId: system.id,
    type: 'system' as const,
    data: {
      systemCode: system.systemCode,
      systemName: system.systemName,
      versionsCount: system._count.versions,
      isActive: system.isActive,
    },
  }))

  // Формируем ребра графа
  const edges = connections.map((conn: any) => ({
    id: `connection-${conn.id}`,
    source: `system-${conn.sourceSystemId}`,
    target: `system-${conn.targetSystemId}`,
    label: conn.dataFormat,
    data: {
      connectionId: conn.id,
      dataFormat: conn.dataFormat,
      isBidirectional: conn.isBidirectional,
    },
  }))

  return { nodes, edges }
}
